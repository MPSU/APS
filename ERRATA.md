# Список исправлений

![http://95.215.8.74:5000/days_since_last_commit.png](http://95.215.8.74:5000/days_since_last_commit.png)

**27.10.2025**: Исправлена опечатка в описании функционального поведения ведомой защёлки в составе D-триггера на стр. 41:

```diff
- пока сигнал `clk = 0`
+ пока сигнал `clk = 1`
```

<details>
  <summary> Исправленная версия предложения </summary>

Несмотря на то, что ведомая защёлка "прозрачна" всё то время, пока сигнал `clk = 1`, данные в ней остаются стабильными, поскольку выход ведущей защёлки больше не может измениться.

</details>

<br><br>

**22.05.2025**: Исправлено несоответствие в названиях модулей в ЛР10-12.

- `irq_controller` следует читать как `interrupt_controller`;
- `processor_unit` следует читать как `processor_system`.

В рисунке II.12-3 добавлена разрядность сигнала `irq_ret_o` (должна быть 16 бит).

<details>
<summary> Обновлённый рисунок </summary>

![.pic/Labs/lab_12_daisy_chain/fig_03.drawio.svg](.pic/Labs/lab_12_daisy_chain/fig_03.drawio.svg)

_Рисунок II.12-3. Структурная схема блока приоритетных прерываний._

</details>

<br><br>

**13.05.2025**: Исправлен рисунок II.8-3 — исправлена опечатка в названии нижнего сигнала (`mem_wd_i` → `mem_wd_o`).

<details>
<summary> Обновлённый рисунок </summary>

![.pic/Labs/lab_08_lsu/fig_03.wavedrom.svg](.pic/Labs/lab_08_lsu/fig_03.wavedrom.svg)

Рисунок II.8-3. Временна́я диаграмма запросов на запись со стороны ядра и сигнала mem_wd_o.

</details>


## Ошибки, исправленные во втором издании

**25.08.2025**: Обнаружена ошибка в примере формирования управляющих сигналов декодером инструкций на стр. 133. При инструкции `sw`, декодер должен выставить на сигнале `b_sel_o` значение `3'd3`, а не `3'd1`.

<details>
  <summary> Исправленная версия абзаца </summary>

  > Пример: для выполнения инструкции записи 32-бит данных из регистрового файла во внешнюю память (инструкции `sw`), дешифратор должен направить в АЛУ два операнда (базовый адрес и смещение) вместе с кодом операции АЛУ (сложения) для вычисления адреса записи. Базовый адрес берется из регистрового файла, а смещение является непосредственным операндом инструкции S-типа. Таким образом для вычисления адреса записи декодер должен выставить следующие значения на выходах:
  >
  > - `a_sel_o = 2'd0`,
  > - `b_sel_o = 3'd3`,
  > - `alu_op_o= ALU_ADD`.

</details>

<br><br>

**11.07.2025**: Обнаружена ошибка вёрстки в примере использования битовых сдвигов на стр. 79. Операции по установке, очистке и чтению N-го бита выглядят следующим образом:

```C++
X =  X |  (1 << N);       // Установка N-го бита
X =  X & ~(1 << N);       // Очистка N-го бита
Y = (X &  (1 << N)) != 0; // Чтение N-го бита
```

<br><br>

**11.07.2025**: Исправлена опечатка в предпоследнем абзаце стр. 227 (в конце первого предложения должен был быть написан **LMA**):

```diff
- задав какой-нибудь заведомо большой VMA для секции данных
+ задав какой-нибудь заведомо большой LMA для секции данных
```

<details>
<summary> Исправленная версия абзаца </summary>

> Таким образом, мы можем сделать общие VMA (процессор, обращаясь к секциям инструкций и данных будет использовать пересекающееся адресное пространство), а конфликт размещения секций компоновщиком разрешить, задав какой-нибудь заведомо большой LMA для секции данных. В последствии, мы просто проигнорируем этот адрес, проинициализировав память данных начиная с нуля.

</details>

<br><br>

**16.06.2025**: Исправлена ошибка в _листинге II.14-2_.

Предпоследнюю инструкцию (`lw a0, 40(a0)`) следует читать как `lw a0, 24(a0)`.

<br><br>

**29.03.2025**: Исправлен рисунок II.4-4 — убрана логика безусловного перехода, т.к. она должна была появиться только в следующем параграфе.

<details>
<summary> Обновлённый рисунок </summary>

![.pic/Labs/lab_04_cybercobra/ppd_4.drawio.svg](.pic/Labs/lab_04_cybercobra/ppd_4.drawio.svg)

Рисунок II.4-4. Реализация условного перехода.

</details>
