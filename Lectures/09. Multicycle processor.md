# Лекция 9. Многотактный процессор RISC-V

Основными минусами однотактного процессора является: неэффективность использования аппаратуры и долгий тактовый импульс, ориентированный на выполнение самой длинной (долгой) инструкции.

Многотактная микроархитектура предполагает использование буферных (неархитектурных, то есть недоступных программисту) регистров, с целью уменьшения критического пути и поднятия таковой
частоты. При этом каждая инструкцию будет выполняться несколько более коротких тактов, используя разное количество тактов для реализации разных инструкций.

Благодаря выполнению инструкции за несколько тактов, в этой микроархитектуре получилось реализовать принстонскую архитектуру (она же фоннеймановская, то есть данные и программы хранятся в одной памяти) и уменьшить количество сумматоров, за счет выполнения всех вычислительных операций на одном АЛУ. Еще одним из основных отличий от однотактной реализации является устройство управления (Control Unit), которой, в отличии от основного дешифратора (Main Decoder) однотактного процессора, является последовательностным устройством, а не комбинационным. Это значит, что в устройстве управления есть элементы памяти, и он ведет себя как автомат состояний (конечный автомат). Control Unit, в зависимости от выполняемой инструкции формирует *последовательность* управляющих сигналов, обеспечивающих движение данных по тракту данных от секции к секции, такт за тактом, пока инструкция не будет выполнена.

![../.pic/Lectures/09.%20Multicycle%20processor/fig_01.png](../.pic/Lectures/09.%20Multicycle%20processor/fig_01.png)

Устройство управления (УУ) для такого процессора может быть построено одним из двух способов:

- на жесткой логике (в таком случае, УУ является классическим конечным автоматом. Это наиболее быстрая реализация УУ, однако, его сложнее проектировать и отлаживать, чем второй подход, а после производства и выпуска работу устройства нельзя скорректировать)
- устройство с микропрограммным управлением (по сути является маленьким программируемым устройством, хранящим последовательность управляющих сигналов для процессора в виде небольших микропрограмм, последовательно считываемых из управляющей памяти и выдаваемых на выходы Y — на схеме микроархитектуры отмечены синим цветом. Каждая инструкция процессора провоцирует запуск определенной микропрограммы из управляющей памяти).

Устройства с микропрограммным управлением (УМУ) сами могут быть построены одним из двух способов, отличающиеся способом адресации следующей микроинструкции:

- УМУ с принудительной адресацией
- УМУ с естественной адресацией

В первом случае в каждой микроинструкции помимо операционной части (где хранятся значения управляющих сигналов для процессора) присутствуют еще три поля: два поля адреса и поле признака, кодирующего информацию о том, какие флаги от операционных устройств надо проверить. Если флаги совпадают с указанными в микроинструкции, то следующей загружается микроинструкция по адресу из первого поля, в противном случае — из второго.

Такой подход плох тем, что одно поле адреса микроинструкции никогда не используется, так как всегда имеет смысл и выбирается только одно из двух. За счет этого увеличивается необходимый объем памяти, что приводит к замедлению скорости работы устройства (большая память = медленная память).

![../.pic/Lectures/09.%20Multicycle%20processor/fig_02.png](../.pic/Lectures/09.%20Multicycle%20processor/fig_02.png)

Альтернативный подход: УМУ с естественной адресации. В подобном устройстве микроинструкция состоит из 3 полей: операционная часть (либо адресная), поле флагов, которые надо проверить у операционных устройств и поле признака, сообщающее что сейчас в основной части (операция или адрес новой микроинструкции). В обычной ситуации, если поле признака равно 0, счетчик, в составе этого УМУ, с каждым таком увеличивается, указывая каждый раз на следующую микрокоманду. При этом в самой микрокоманде хранится операционная часть (управляющие сигналы для процессора). Но, если значения признака равно 1, это значит, что в микроинструкции вместо операционной части находится адрес, который будет загружен в счетчик, если флаги указанный в микрокоманде соответствуют флагам, поступаемых от операционных устройств.

![../.pic/Lectures/09.%20Multicycle%20processor/fig_03.png](../.pic/Lectures/09.%20Multicycle%20processor/fig_03.png)

Такой подход позволяет значительно уменьшить управляющую память, за счет чего она получится быстрее. Однако, микроинструкции ветвления, при таком подходе, требуют дополнительного такта на обработку (когда признак равен 1 нет операционной части).

Когда управляющая память хранит значения всех сигналов процессора в естественной форме, это называется *горизонтальным микропрограммированием*. Это значит, что, если устройство управления должно формировать, например, 50 управляющих сигналов для всех блоков процессора, то каждая микроинструкция будет включать в себя операционную часть длинной в 50 бит, то есть отдельный бит для каждого управляющего сигнала.

Горизонтальное микропрограммирование не требует наличие дешифратора на выходе УМУ, однако, для хранения всех значений сигнала потребуется относительно большая память, что повлияет на скорость ее работы. Альтернативой является *вертикальное микропрограммирование*, в котором каждой длинной последовательности сигналов (например, 50 в нашем примере) ставится в соответствие более короткая последовательность (например, из 10 бит). В таком случае на выходе УМУ требуется расположить дешифратор, который будет преобразовывать короткий код в длинный.

С одной стороны это уменьшает  объем требуемой памяти (хорошо отражается на ее скорости), но дешифратор сам имеет задержку распространения сигнала, а значит уменьшает эффект от уменьшения ее объема.

Золотая середина — *квазивертикальное* (*горизонтально-вертикальное*) *микропрограммирование*, при котором  стараются найти баланс между степенью сжатия микроинструкций и величиной дешифратора на выходе УМУ.

## Основные материалы лекции

1. [Ссылка](https://www.youtube.com/watch?v=xHefXrFNI0M) на видеозапись лекции
2. По вопросу синтеза многотактного процессора та же проблема с литературой. Либо смотреть запись лекции, либо ориентироваться на полный процесс синтеза многотактного процессора в тексте, но на примере архитектуры MIPS [***Харрис и Харрис***. *Цифровая схемотехника и архитектура компьютера* — весь параграф 7.4]
3. Про устройство управления с жесткой логикой и с микропрограммным управлением [***Кафедра ВТ***. *Микропроцессорные средства и системы* — Лекция 2.1]

## Дополнительные материалы для саморазвития

1. Более развернутое, однако при этом и более сухое, описание вариантов реализации устройства управления. В этом источнике, например, разбирается нанопрограммное управление, которое не затрагивалось на лекции, и есть пример реализации УУ на жесткой логике (тут, правда, это называется аппаратной логикой — суть одна) [***Орлов и Цилькер***. *Организация ЭВМ и систем* — Глава 4. три параграфа начинающиеся со слов 'Микропрограммный автомат…']
2. Еще один синтез многотактного процессора, но с архитектурой ARM. Похоже на RISC-V и MIPS, но со своими тонкостями. А еще, чтобы усвоить материал придется предварительно прочитать всю первую главу книги про архитектуру ARM [***Харрис и Харрис***. *Цифровая схемотехника и архитектура компьютера. Дополнение по архитектуре ARM* — весь параграф 2.4]

## Популярные материалы

1. [Обязательно к просмотру!](http://buthowdoitknow.com/cpu_model_intro.html) Рабочая модель процессора с многотактной микроархитектурой и устройством управления с жесткой логикой (с кольцевым счетчиком, все как положено). [Тут](http://buthowdoitknow.com/but_how_do_it_know_cpu_model.html) можно прямо в браузере написать программку и посмотреть потактово\покомандно ее исполнение, рассматривая откуда и куда идут сигнальчики, вникая в самую суть происходящего. Очень интересно и увлекательно.

   Чтобы было понятней происходящее, надо прочесть [описание](http://buthowdoitknow.com/cpu_model_intro.html), либо нажать Details под [схемой](http://buthowdoitknow.com/but_how_do_it_know_cpu_model.html). Нажав на Load sample multiplying 5x5 в открывшемся окне, в окно программы загрузиться стандартный пример, за которым можно понаблюдать при первом ознакомлении с моделью.

   А еще на странице проекта можешь найти вариант модели процессора на Excel.

   ![../.pic/Lectures/09.%20Multicycle%20processor/fig_04.jpg](../.pic/Lectures/09.%20Multicycle%20processor/fig_04.jpg)
